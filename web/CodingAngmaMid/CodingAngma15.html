<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <title>Page Title</title>
</head>
<body>
    <script>

        // class
        // 지금까지 비슷한 형태의 객체를 생성하기 위해서 생성자 함수를 이용했다

        const User = function(name, age) {
            this.name = name;
            this.age = age;
             /* this.showName = function() {
                console.log(this.name);
            }; */
        }

        // 생성자 함수에서 class처럼 프로토타입 내부에 showName을 위치시키는 방법
        User.prototype.showName = function() {
            console.log(this.name);
        }
        const mike = new User("Mike", 30); // 객체 내부에 showName이 있고 

        class User2 {
            constructor(name, age) { // 객체를 만들어주는 생성자 매서드
                this.name = name;
                this.age = age;
            }
            showName() {
                console.log(this.name);
            }
        }

        const tom = new User2("Tom", 19); // 프로토타입 내부에 showName이 있다

        // 생성자함수에서는 new를 빼고 실행해도 실행은 된다 undefined
        // class를 사용하면 new없이 실행될 수 없다는 에러가 발생

        for (const p in mike) {
            console.log(p);
        } // name age showName

        for (const p in tom) {
            console.log(p);
        } // name age  class의 매서드는 for in문에서 제외된다




        // class 의 상속
        // extends 키워드 사용

        class Car {
            constructor(color) {
                this.color = color;
                this.wheels = 4;
            }
            drive() {
                console.log("drive..");
            }
            stop() {
                console.log("STOP!");
            }
        }

        class Bmw extends Car {
            constructor(color) {
                super(color);
                this.navigation = 1;
            }
            park() {
                console.log("PARK");
            }
            stop() {
                console.log("OFF");
            }
            drive() {
                super.drive();
                console.log("Super Drive...");
            }
        }

        const z4 = new Bmw("blue");
        console.log(z4);
        




        // class 매소드 오버라이딩
        // 동일한 이름의 매서드가 있다면 덮어쓰이게 된다 console.log(z4.stop()) // OFF
        // 부모와 동일한 이름의 매서드를 사용하면서 확장하고 싶다면 super라는 키워드를 사용한다
        // console.log(z4.drive()); // drive..(car의 drive),, Super Drive...(z4의 drive)

        // constructor 오버라이딩
        // class의 constructor 는 빈객체를 만들고 this로 빈 객체를 가르키게 된다
        // 반면 extends를 사용한 자식 class는 빈객체를 만들고 this로 할당하는 작업을 건너뛴다
        // 그렇기 때문에 super를 사용해서 부모 class의 constructor를 실행해야한다
        // 또한 부모와 동일한 인수를 받는 작업을 해야한다. (color)

        

    </script>
    
</body>
</html>